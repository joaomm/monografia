\chapter{Introdução}
\label{chap:introducao}

A indústria de software busca continuamente por melhorias nos métodos
de desenvolvimento. Do ponto de vista prático, os processos tradicionais investem tempo especificando requisitos
e planejando a arquitetura do software para que o trabalho possa ser dividido entre os
programadores, cujo trabalho é transformar o design anteriormente concebido em código.
Diante de uma perspectiva dos métodos ágeis, valoriza-se a entrega constante 
de valor ao cliente \cite{}. Por exemplo, se há um agente financiador ou uma comunidade de software livre
como cliente, o foco é na entrega de funcionalidades que possam ser rapidamente colocadas
no ambiente produção e receber ``feedback'' constante.

Em ambos os casos, não há como ignorar o fato de que o código-fonte da aplicação será
desenvolvido gradativamente e diferentes programadores farão alterações e extensões
continuamente. Nesse contexto, as funcionalidades são adicionadas e as falhas sanadas.

Uma situação comum durante o desenvolvimento, é um programador lidar com um trecho que
ainda não teve contato para fazer alterações. Nessa tarefa, por exemplo, (i) lida com métodos extensos e classes
com muitas linhas de código que se comunicam com diversos objetos; (ii) encontra comentários
desatualizados relacionados a uma variável com nome abreviado e sem significado, e (iii) se depara com métodos que
recebem valores booleanos e possuem estruturas encadeadas complexas com muitas operações duplicadas.

Portanto, depois um longo período de leitura, o desenvolvedor encontra o trecho de lógica em que deve 
fazer a mudança. A alteração freqüentemente consiste na modificação de poucas linhas e o 
desenvolvedor tem seu trabalho como terminado, sem ter feito melhorias no código complexo com o qual enfrentou dificuldades.

O quadro exemplificado ilustra uma circustância com aspectos a serem observados.
Primeiramente, há uma diferença significativa na proporção entre linhas lidas e as inseridas.
Para cada uma das poucas linhas que escreveu, o desenvolvedor teve que compreender muitas
outras \cite{}. Além disso, não houve melhorias na clareza ou flexibilidade do código, fazendo 
com que os responsáveis pela próxima alteração, seja o próprio desenvolvedor ou o seguinte,
tenham que enfrentar a mesma dificuldade.

Tendo essa situação em vista, nesse trabalho apresentamos um estilo de programação baseado
no paradigma da Orientação a Objetos que busca o que denominamos ``Código Limpo'', concebido e aplicado por renomados desenvolvedores de software
como Robert C. Martin \cite{} e Kent Beck \cite{}. Baseado em testes e decisões técnicas que visam a clareza, flexibilidade
e simplicidade do código-fonte, um código limpo pode ter um impacto importante no desenvolvimento 
de software, aumentando a produtividade e diminuindo os custos de manutenção.

Para promover o teste dessas hipóteses, ao longo desta monografia, também abordaremos uma maneira objetiva fazer um mapeamento objetivo 
entre os conceitos relaciados a um código limpo e métricas de código-fonte. Em resumo, além de poderem ser
automatizadas computacionalmente, os valores das métricas podem dar uma base de comparação entre
as versões de um mesmo software e destacar trechos que poderiam sofrer alterações relacionadas à ``limpeza do código''.

\section{Objetivos}
\label{sec:objetivo}


O primeiro objetivo deste trabalho é apresentar um levantamento teórico de conceitos relacionados ao que denominamos de 
código limpo, buscando expor um conjunto de técnicas e boas decisões que possam ser adotadas ao longo do 
desenvolvimento para auxiliar a criação de um código mais expressivo, simples e flexível. Essa apresentação permite um 
contato com recomendações e preocupações de desenvolvedores de software reconhecidos internacionalmente ao trabalharem com 
o paradigma da Orientação a Objetos.

Além disso, também temos como objetivo o mapeamento entre um grupo de métricas de código-fonte e os conceitos acima 
citados, de forma a facilitar a detecção de trechos de código que poderiam receber refatorações e melhorias. Para que as 
métricas possam ser mais facilmente incorporadas no cotidiano dos programadores, também temos como objetivo a apresentação 
de uma maneira de interpretar os valores das métricas.

Deste modo, queremos apresentar uma maneira de utilizar o poder da automatização das métricas associada a sua interpretação, facilitando assim a aproximação para com os conceitos relacionados com código limpo.

\section{Metodologia}
\label{sec:metodologia}

Metodologia

%% ------------------------------------------------------------------------- %%
\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

Além dessa introdução, este texto está organizado em quatro capítulos.

No Capítulo~\ref{chap:codigo_limpo}, apresentamos o que é um código limpo através
da união das concepções de importantes especialistas no desenvolvimento de software.
O foco será nos livros \textit{Clean Code} de Robert Martin [REF] e \textit{Implementation
Patterns} de Kent Beck [REF] e serão apresentados tantos conceitos teóricos
quanto técnicas conhecidas para a criação de um código expressivo, simples e flexível.

O capítulo seguinte, Capítulo~\ref{chap:metricas}, mostra o conceito das métricas de 
código-fonte e como podemos utilizá-las para extrair características importantes do
código. Além disso, apresentaremos o mapeamento objetivo entre os aspectos levantados
no capítulo anterior e as métricas para auxiliar os programadores.

No Capítulo~\ref{chap:ferramentas} apresentamos as ferramentas que estão sendo desenvolvidas
no contexto de nossa iniciação científica e no doutorado de Paulo Meirelles e Antonio Terceiro.

Por fim, as conclusões e possibilidades de trabalhos futuros serão trabalhos no Capítulo~\ref{chap:conclusao}