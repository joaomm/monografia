\chapter{Mapeamento de Código Limpo em Métricas de Código-fonte}
\label{chap:mapeamento}	

	Após a discussão teórica realizada na primeira parte dessa 	monografia, apresentaremos um mapeamento dos conceitos de código limpo em métricas de código-fonte. Nesse mapeamento usamos um conjunto de métricas para automatizar a busca por características do código-fonte. Em seguida, criamos uma interpretação dos valores das métricas, fazendo associações entre eles e as técnicas e conceitos relacionados a limpeza do código. Nosso objetivo é facilitar a detecção de trechos que poderiam sofrer alterações que os tornem mais expressivos, simples e flexíveis.


\section{Métricas de Código-fonte}

	Métricas são mecanismos automatizáveis para detecção de características obtidas através da análise do código-fonte.
	
	Existem várias abordagens diferentes para o uso de métricas. Em muitas pesquisas elas são usadas como mecanismos que permitem encontrar características nos códigos-fonte. Essas características serão usadas, por exemplo, na avaliação da qualidade do software (Meirelles e Kon, 2009) [REF], ou para serem relacionadas com atributos dos projetos de software livre (trabalho estatístico do Paulo e do Carlos Denner). 
	
	No contexto de métodos ágeis, as métricas são importantes parâmetros para \textit{tracking} de projetos (acompanhamento do desenvolvimento do projeto). Por exemplo, contando linhas de código já produzidas, ou no cálculo da cobertura de teste.	Além disso, elas estão presentes na abordagem do modelo GQM (Goal, Question, Metrics), que é utilizado para gestão de projetos através da formulação de objetivos e questões que auxiliam na interpretação dos valores das métricas escolhidas.
	
	Nessa monografia usaremos uma abordagem baseada na determinação de um conjunto de métricas que seja facilmente interpretado e que visa encontrar trechos de código que precisem de melhorias quanto a sua limpeza.
	
	Sabemos que existem muitas métricas e que quanto maior a quantidade delas calculada, mais difícil compreender os seus valores. Essa dificuldade é suficientemente grande para motivar a criação de ferramentas que automatizam a interpretação dos resultados obtidos.	Uma dessas ferramentas é a Kalibro, descrita no artigo (Crab - Paulo) [REF]. A mesma permite que o usuário configure intervalos numéricos que possibilitam uma interpretação qualitativa do valor de cada métrica. Assim, podemos usar intervalos como ``Bom'', ``Regular'' e ``Ruim'' ao invés de usar ``0 a 1/3'', ``1/3 a 2/3'' e ``2/3 a 1'', facilitando o entendimento e a classificação dos aspéctos medidos a partir do código-fonte.
	
	No entanto, ao considerar o uso de uma ferramenta como a Kalibro nesse trabalho, encontramos algumas dificuldades. Uma é a dependência da combinação de métricas para encontrar as características que procuramos, uma vez que há apenas suporte na Kalibro para interpretação de cada valor separadamente e não para conjuntos deles. Outro problema consiste em como definir os intervalos numéricos. Por exemplo, podemos usar os conceitos apresentados por Robert Martin [REF] para definir essas referências. Porém, temos que considerar que diferentes linguagens e domínios de aplicação precisam de padrões de implementação distintos, como comenta Kent Beck [REF].	
	
	Para evitar esses problemas selecionamos um subconjunto pequeno de métricas que espelha bem as características de código limpo procuradas. A seleção feita não é a única capaz de suprir os mesmos objetivos, pois outras combinações podem ser propostas e obter resultados semelhantes.
		
	Na formação desse subconjunto, a minimalidade não foi uma restrição. Optamos por não eliminar todas as métricas correlacinadas, pois em alguns casos, mesmo que elas indiquem coisas parecidas, elas nos fornecem alguns outros dados bastante relevantes.
	
	Dado a dificuldade em fixar valores para a interpretação das métricas, o mapeamento desenvolvido nessa pesquisa não tem como objetivo afirmar se um código é limpo ou não. Nossa proposta é formar um conjunto de métricas cujos valores expressem diferentes cenários relacionados com melhorias quanto a limpeza do código.
	
	
\section{O Mapeamento}

	O mapeamento proposto nesse trabalho visa facilitar a procura por problemas quanto a limpeza do código. A ideia é criar cenários que relacionem os conceitos de código limpo com métricas de código fonte. Cada cenário é descrito através dos seguintes componentes:
	
\begin{itemize}
	\item Referências: conceitos de limpeza de código que motivaram a criação do cenário.
	\item Características: indicam a presença de falhas em relação as referências apresentadas.
	\item Métricas: mecanismos que permitem analisar o código a procura das características do cenário.
	\item Objetivo: quais devem ser as ideias principais durante a refatoração para eliminar o problema.
	\item Resultados Esperados: quais características devem ser encontradas no código quando terminar a refatoração para eliminação do cenário.
\end{itemize}	

	
	Quando algum desses cenários é detectado, sugerimos que o usuário analise o trecho indicado verificando se é possível refatorar o código para melhorar sua limpeza. Esse mapeamento não visa afirmar se existem problemas no código, mas sim indicar partes dele que talvez possam ser melhoradas de acordo com os importantes conceitos discutidos nessa trabalho.

	Para incentivar a avaliação de códigos ao longo de seu desenvolvimento, é muito importante que sua interpretação seja simples. Esperamos que a preocupação com a limpeza do código não emerja apenas quando ele estiver pronto. Nessa fase é provável que ele tenha vários problemas e que seja muito complicado fazer alterações nele. Por esse motivo, montamos aguns cenários e escolhemos um conjunto pequeno de métricas que nos permite detectar as características procuradas.
	
	Infelizmente, não é possível mapear todos os conceitos de código limpo usando métricas. Por exemplo, não consguimos encontrar problemas relacionados a nomes pouco expressivos usando apenas métricas. Nesse caso, não é suficiente analisarmos a estrutura do código, precisaríamos entender o contexto em que cada nome é usado, e para isso, seria necessária uma análise semântica.

	Existem dois tipos de métricas de código fonte. Algumas avaliam características de métodos, outras de classes. As métricas do segundo tipo são normalmente somas ou médias dos valores das avaliadoras de métodos. Essa divisão de alvo do análise das métricas também existe no contexto dos cenários.


\subsection{Conjunto de Métricas}


\subsection{Os Cenários}

\subsubsection{Método grande}


ESCREVER ALGUMA COISA COMO INTRODUCAO DESSA PARTE
 
\subsubsection{Método grande}

	Como já foi discutido nesse trabalho, métodos grandes são indesejáveis pois dificultam o entendimento e a diminuem a flexibilidade do código. Características comuns encontradas neles são: 
	
\begin{itemize}
	\item realização de várias atividades, quando deveria ser responsável por apenas uma;
	\item grande número de linhas (algumas vezes, muito maior que a média do número de linhas dos métodos da sua classe). Usamos a métrica \textit{LOC} para calcular a quantidade de linhas efetivas de cada método;
	\item muitas estruturas encadeadas. Usamos a métrica \textit{MAXNESTING} para calcular o nível máximo de estruturas encadeadas no método;
	\item muitos fluxos diferentes. Usamos a métrica \textit{Cyclo} que mostra a complexidade ciclomática que calcula o número de caminhos linearmente independentes presentes no método avaliado;
\end{itemize}

	Quando nos deparamos com um método com alguma, ou algumas dessas características, nossos objetivos são:
	
\begin{itemize}
	\item ESCREVER OS OBJETIVOS.....
\end{itemize}
	
	


\subsubsection{Método com muitos fluxos condicionais}
\subsubsection{Método com muitos parâmetros}
\subsubsection{Muita repassagem de parâmetro pela classe}

	